// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4531.ItsAbrandnewDave;
import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.opencv.core.RotatedRect;
import org.usfirst.frc4531.ItsAbrandnewDave.commands.*;
import org.usfirst.frc4531.ItsAbrandnewDave.subsystems.*;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;
import com.ctre.phoenix.motorcontrol.can.*;
import com.ctre.phoenix.motion.BufferedTrajectoryPointStream;
import com.ctre.phoenix.motion.TrajectoryPoint;
import com.ctre.phoenix.motorcontrol.*;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the TimedRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the build.properties file in 
 * the project.
 */
public class Robot extends TimedRobot {

    Command autonomousCommand;
    SendableChooser<Command> chooser = new SendableChooser<>();
    public static Constants constantValues;
    public static OI oi;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static wingDeploy wingDeploy;
    public static grabberMech grabberMech;
    public static climbFront climbFront;
    public static climbBack climbBack;
    public static driveSubsystem driveSubsystem;
    BufferedTrajectoryPointStream _bufferedStreamCanEight = new BufferedTrajectoryPointStream();
    TrajectoryPoint point = new TrajectoryPoint();
    int canNineCounterInt = 0;
    Boolean canNineJustStopped = true;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
    @Override
    public void robotInit() {
        CameraServer.getInstance().startAutomaticCapture();         
        
        
        wingDeploy = new wingDeploy();
        grabberMech = new grabberMech();
        climbFront = new climbFront();
        climbBack = new climbBack();
        driveSubsystem = new driveSubsystem();
        PlotThread _PlotThread9 = new PlotThread(Robot.climbBack.canNine);
        PlotThread _plotThread8 = new PlotThread(Robot.climbFront.canEight);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // OI must be constructed after subsystems. If the OI creates Commands
        //(which it very likely will), subsystems are not guaranteed to be
        // constructed yet. Thus, their requires() statements may grab null
        // pointers. Bad news. Don't move it.
        oi = new OI();

        // Add commands to Autonomous Sendable Chooser
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

        chooser.setDefaultOption("Autonomous Command", new AutonomousCommand());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
        SmartDashboard.putData("Auto mode", chooser);
    }

    /**
     * This function is called when the disabled button is hit.
     * You can use it to reset subsystems before shutting down.
     */
    @Override
    public void disabledInit(){

    }

    @Override
    public void disabledPeriodic() {
        Scheduler.getInstance().run();
    }

    @Override
    public void autonomousInit() {
        autonomousCommand = chooser.getSelected();
        // schedule the autonomous command (example)
        if (autonomousCommand != null) autonomousCommand.start();
    }

    /**
     * This function is called periodically during autonomous
     */
    @Override
    public void autonomousPeriodic() {
        Scheduler.getInstance().run();
    }

    @Override
    public void teleopInit() {
        Robot.driveSubsystem.canThree.follow(Robot.driveSubsystem.canOne);
        Robot.driveSubsystem.canSix.follow(Robot.driveSubsystem.canFour);
       
        Robot.climbFront.canEight.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative,Constants.kPIDLoopIdx, Constants.kTimeoutMs);
        Robot.climbBack.canNine.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative,Constants.kPIDLoopIdx, Constants.kTimeoutMs);
        Robot.climbFront.canEight.configReverseLimitSwitchSource(LimitSwitchSource.FeedbackConnector, LimitSwitchNormal.NormallyOpen);
        Robot.climbBack.canNine.configReverseLimitSwitchSource(LimitSwitchSource.FeedbackConnector, LimitSwitchNormal.NormallyOpen);
        Robot.climbBack.canNine.configClearPositionOnLimitR(true, Constants.kTimeoutMs);
       
        Robot.climbFront.canEight.setSensorPhase(false);
        Robot.climbBack.canNine.setSensorPhase(false);
        Robot.climbFront.canEight.setInverted(Constants.kMotorInvert);
        Robot.climbBack.canNine.setInverted(Constants.kMotorInvert);

        Robot.climbBack.canNine.configNominalOutputForward(0, Constants.kTimeoutMs);
		Robot.climbBack.canNine.configNominalOutputReverse(0, Constants.kTimeoutMs);
		Robot.climbBack.canNine.configPeakOutputForward(1, Constants.kTimeoutMs);
		Robot.climbBack.canNine.configPeakOutputReverse(-1, Constants.kTimeoutMs);

		Robot.climbBack.canNine.config_kF(Constants.kPIDLoopIdx, Constants.kGains.kF, Constants.kTimeoutMs);
		Robot.climbBack.canNine.config_kP(Constants.kPIDLoopIdx, Constants.kGains.kP, Constants.kTimeoutMs);
		Robot.climbBack.canNine.config_kI(Constants.kPIDLoopIdx, Constants.kGains.kI, Constants.kTimeoutMs);
		Robot.climbBack.canNine.config_kD(Constants.kPIDLoopIdx, Constants.kGains.kD, Constants.kTimeoutMs);

        Robot.climbFront.canEight.configNominalOutputForward(0, Constants.kTimeoutMs);
		Robot.climbFront.canEight.configNominalOutputReverse(0, Constants.kTimeoutMs);
		Robot.climbFront.canEight.configPeakOutputForward(.2, Constants.kTimeoutMs);
		Robot.climbFront.canEight.configPeakOutputReverse(-.2, Constants.kTimeoutMs);

		Robot.climbFront.canEight.config_kF(Constants.kPIDLoopIdx, Constants.kGains_MotProf.kF, Constants.kTimeoutMs);
		Robot.climbFront.canEight.config_kP(Constants.kPIDLoopIdx, Constants.kGains_MotProf.kP, Constants.kTimeoutMs);
		Robot.climbFront.canEight.config_kI(Constants.kPIDLoopIdx, Constants.kGains_MotProf.kI, Constants.kTimeoutMs);
        Robot.climbFront.canEight.config_kD(Constants.kPIDLoopIdx, Constants.kGains_MotProf.kD, Constants.kTimeoutMs);
        Robot.climbFront.canEight.config_IntegralZone(Constants.kPIDLoopIdx, Constants.kGains_MotProf.kIzone);
        Robot.climbFront.canEight.configClosedLoopPeakOutput(Constants.kPIDLoopIdx, Constants.kGains_MotProf.kPeakOutput, Constants.kTimeoutMs);
        
        Robot.climbFront.canEight.configAllowableClosedloopError(0, Constants.kPIDLoopIdx, Constants.kTimeoutMs);
        Robot.climbBack.canNine.configAllowableClosedloopError(0, Constants.kPIDLoopIdx, Constants.kTimeoutMs);

        int absPositionFront = Robot.climbBack.canNine.getSensorCollection().getPulseWidthPosition();

        absPositionFront &= 0xFFF;
		if (Constants.kSensorPhase) { absPositionFront *= -1; }
		if (Constants.kMotorInvert) { absPositionFront *= -1; }
		
		/* Set the quadrature (relative) sensor to match absolute */
        Robot.climbBack.canNine.setSelectedSensorPosition(absPositionFront, Constants.kPIDLoopIdx, Constants.kTimeoutMs);

            int absPositionBack = Robot.climbFront.canEight.getSensorCollection().getPulseWidthPosition();
        
        absPositionBack &= 0xFFF;
		if (Constants.kSensorPhase) { absPositionBack *= -1; }
		if (Constants.kMotorInvert) { absPositionBack *= -1; }
		
		/* Set the quadrature (relative) sensor to match absolute */
	    Robot.climbFront.canEight.setSelectedSensorPosition(absPositionBack, Constants.kPIDLoopIdx, Constants.kTimeoutMs);
        //Robot.climbFront.canEight.follow(Robot.climbBack.canNine);
        // This makes sure that the autonomous stops running when
        // teleop starts running. If you want the autonomous to
        // continue until interrupted by another command, remove
        // this line or comment it out.
        if (autonomousCommand != null) autonomousCommand.cancel();
    }

    /**
     * This function is called periodically during operator control
     * 
     */
    
    double targetPositionRotations;
    boolean _lastButton1;
     @Override
    public void teleopPeriodic() {
        double leftYstick = -1 * Robot.oi.joyStick.getRawAxis(3);
        double motorOutputBack = Robot.climbBack.canNine.getMotorOutputPercent();
        double motorOutputFront = Robot.climbFront.canEight.getMotorOutputPercent();

        boolean button1 = Robot.oi.joyStick.getRawButton(11);	// X-Button
        boolean button2 = Robot.oi.joyStick.getRawButton(12);	// A-Button
        
        if (Math.abs(leftYstick) < 0.10) {
			/* Within 10% of zero */
			leftYstick = 0;
        }
        
        if (!_lastButton1 && button1) {
            /* Position Closed Loop */
            _bufferedStreamCanEight.Clear();
            canNineCounterInt = 0;
            canNineJustStopped = false;

			/* 10 Rotations * 4096 u/rev in either direction */
			targetPositionRotations = leftYstick * 10.0 * 4096;
           
            Robot.climbBack.canNine.set(ControlMode.Position, targetPositionRotations);
            //Robot.climbFront.canEight.set(ControlMode.Position, Robot.climbBack.canNine.getSelectedSensorPosition());
            Robot.climbFront.canEight.startMotionProfile(_bufferedStreamCanEight, 1, ControlMode.MotionProfile);
        }
        if (Robot.climbBack.canNine.getSelectedSensorVelocity() > 0) {
            canNineCounterInt++;
            point.timeDur = 25;
            point.position = Robot.climbBack.canNine.getSelectedSensorPosition(); // Convert Revolutions to
                                                                                          // Units
            point.velocity = Robot.climbBack.canNine.getSelectedSensorVelocity(); // Convert RPM to
                                                                                                  // Units/100ms
            point.auxiliaryPos = 0;
            point.auxiliaryVel = 0;
            point.profileSlotSelect0 = Constants.kPIDLoopIdx; /* which set of gains would you like to use [0,3]? */
            point.profileSlotSelect1 = 0; /* auxiliary PID [0,1], leave zero */
            point.zeroPos = (canNineCounterInt == 0); /* set this to true on the first point */
            point.isLastPoint = (false); /* set this to true on the last point */
            point.arbFeedFwd = 0; /* you can add a constant offset to add to PID[0] output here */

            _bufferedStreamCanEight.Write(point);
        } else if(!canNineJustStopped ) {
            canNineJustStopped = true;
            point.timeDur = 25;
            point.position = Robot.climbBack.canNine.getSelectedSensorPosition(); // Convert Revolutions to
                                                                                          // Units
            point.velocity = Robot.climbBack.canNine.getSelectedSensorVelocity(); // Convert RPM to
                                                                                                  // Units/100ms
            point.auxiliaryPos = 0;
            point.auxiliaryVel = 0;
            point.profileSlotSelect0 = Constants.kPIDLoopIdx; /* which set of gains would you like to use [0,3]? */
            point.profileSlotSelect1 = 0; /* auxiliary PID [0,1], leave zero */
            point.zeroPos = (false); /* set this to true on the first point */
            point.isLastPoint = ((true)); /* set this to true on the last point */
            point.arbFeedFwd = 0; /* you can add a constant offset to add to PID[0] output here */

            _bufferedStreamCanEight.Write(point);
        }

        _lastButton1 = button1;
        
        SmartDashboard.putNumber("axisValue",Robot.oi.joyStick.getRawAxis(3));
        SmartDashboard.putNumber("sensorPositionFront",Robot.climbFront.canEight.getSelectedSensorPosition());
        SmartDashboard.putNumber("sensorPositionBack",Robot.climbBack.canNine.getSelectedSensorPosition());
        SmartDashboard.putNumber("rotationTarget",targetPositionRotations);
        SmartDashboard.putNumber("backMotorVelocity", Robot.climbBack.canNine.getSelectedSensorVelocity());
        Scheduler.getInstance().run();
    }
}
